LRP      TITLE 'MAILLRP     Columbia Univ Network MAILER (Rel. 2)      *
               LALR(1) Table-driven parser'
*-------------------------------------------------------------------*
*                                                                   *
*        Columbia University Network MAILER  -  Release 2           *
*                                                                   *
*        Program property of Columbia University                    *
*                                                                   *
*-------------------------------------------------------------------*
         SPACE ,
*-------------------------------------------------------------------*
*                                                                   *
* Module Name:                                                      *
*                                                                   *
*        MAILLRP                                                    *
*                                                                   *
* Function:                                                         *
*                                                                   *
*        LALR(1) parser for tables generated by the PAT parser      *
*        generator written by G. Poonen.                            *
*                                                                   *
* Attributes:                                                       *
*                                                                   *
*        Reentrant                                                  *
*                                                                   *
* Entry Points:                                                     *
*                                                                   *
*        LRPARSE                                                    *
*                                                                   *
* Entry Conditions:                                                 *
*                                                                   *
*        R1    = A(PARMS)    see PARMS DSECT, below                 *
*        R15   = A(LRPARSE)                                         *
*        R14   = return address                                     *
*        R13   = register save area                                 *
*                                                                   *
* Sample Invocation:                                                *
*                                                                   *
*        CALL LRPARSE,(table,stack,length,comm)                     *
*              table         address of tables generated by PAT.    *
*              stack         address of stack pointer               *
*              length        address of stack length                *
*              comm          passed to lexical and                  *
*                            semantic subroutines.                  *
*                                                                   *
* Exit Conditions:                                                  *
*                                                                   *
*        Normal                                                     *
*                                                                   *
*              R15 = 0       Parse completed successfully           *
*                                                                   *
*        Error                                                      *
*                                                                   *
*              R15 = 16      Stack overflow                         *
*              R15 = 20      Syntax error                           *
*              R15 = other   Return codes from other routines       *
*                                                                   *
* Calls to other routines, etc:                                     *
*                                                                   *
*        WRTERM              Write to terminal (debugging)          *
*        WAITT               Wait for terminal (debugging)          *
*        LINEDIT             Write terminal output (debugging)      *
*        MENTRY              Entry linkage macro                    *
*        Other routines      Passed as parameters by caller         *
*                                                                   *
* External References:                                              *
*                                                                   *
*        None                                                       *
*                                                                   *
* Work Areas:                                                       *
*                                                                   *
*        LOCALS DSECT        Allocated from stack                   *
*                                                                   *
* Operation:                                                        *
*                                                                   *
*        The following comment block is from the original parser    *
*        which was written in PASCAL:                               *
*                                                                   *
*          This is the parser driver. It uses the                   *
*        the tables generated by PAT. The driver itself             *
*        is language independent. The only portion                  *
*        that needs to be entered is the semantics as               *
*        indicated. For more details on the parsing method          *
*        see the reference manual for PAT.                          *
*                                                                   *
*        Global                                                     *
*         in/out :  SP       stack pointer for parser               *
*                   CURSTATE current state                          *
*                   SCAN     indicates if next symbol               *
*                            needs to be scanned                    *
*                   PARSE    true while parsing                     *
*                   TOKEN    for making transition                  *
*                   action   parser table                           *
*                   symlist  parser table                           *
*                   poptoken parser table                           *
*                   lhstoken parser table                           *
*                   semantics parser table                          *
*                                                                   *
*        functions used                                             *
*                                                                   *
*         lex       scans the next symbol and must                  *
*                   token to the req'd code                         *
*                                                                   *
*         other user defined semantic routines                      *
*                                                                   *
*        Notes on this implementation:                              *
*                                                                   *
*              1) All parser global variables are in registers.     *
*              2) The parse stack is allocated from the work area   *
*                 passed as a parameter by the caller.              *
*              3) The parser tables,  semantic and lexical          *
*                 subroutine addresses are passed as a parameter.   *
*                 The routines are called with the following linkage*
*                 R0  = Current value of SP                         *
*                 R1  = Communication parameter passed by caller    *
*                 R13 = 18 word save area                           *
*                 R14 = return address                              *
*                 R15 = address of called routine                   *
*                                                                   *
*              4) The lexical routine is expected to return a token *
*                 code in R1 and an error code in R15.  If non-zero,*
*                 this routine terminates with that code in R15.
*              5) The semantic routines return a code in R15 also.  *
*                 Non-zero indicates that the parse is over         *
*                 (equivalent to setting PARSE false).              *
*              6) When debugging a grammar,  you may want to        *
*                 reassemble this module with &DODEBUG set to 1.    *
*                                                                   *
* Alan Crosswell,  12/83                                            *
*-------------------------------------------------------------------*
         EJECT ,
*-------------------------------------------------------------------*
*        Local Macros                                               *
*-------------------------------------------------------------------*
         MACRO
&LABEL   DEBUG &MSG
         GBLA  &DODEBUG
         AIF   (&DODEBUG).DOIT
         MEXIT ,
.DOIT    ANOP
         BAL   R1,DBG&SYSNDX branch over plist
DBS&SYSNDX DC  AL1(L'DBM&SYSNDX)
DBM&SYSNDX DC  C&MSG
DBG&SYSNDX DS  0H
         BAL   R14,DBGPRT    debug print routine
         MEND
         MACRO
&LABEL   LDAR@ &RESULT,&ARRAY,&INDEX
.* R = ARRAY(INDEX)
         LCLC  &ARRY
&ARRY    SETC  '&ARRAY'(1,7) use 1st 7 characters of array name
&LABEL   LR    T1,&INDEX     get the index into temporary
         SLL   T1,2          array is words
         L     T2,A&ARRY     address of the array
         L     &RESULT,0(T1,T2) index into array
         MEND  ,
         MACRO
&LABEL   STAR@ &VALUE,&ARRAY,&INDEX
.* ARRAY(INDEX) = VALUE
         LCLC  &ARRY
&ARRY    SETC  '&ARRAY'(1,8)
&LABEL   LR    T1,&INDEX     get index into temp
         SLL   T1,2          array is words
         L     T2,A&ARRY     address of the array
         ST    &VALUE,0(T2,T1) store into array
         MEND
         GBLA  &DODEBUG
&DODEBUG SETA  0             set to 1 for debugging
         AIF   ('&SYSPARM' EQ 'SUP').NOGEN
         PRINT GEN
         AGO   .SKIPIT
.NOGEN   ANOP
         PRINT NOGEN
.SKIPIT  ANOP
         EJECT ,
*-------------------------------------------------------------------*
*        Parameter List definition                                  *
*-------------------------------------------------------------------*
         SPACE ,
PARMS    DSECT ,
@TABLE   DS    A             address of parse tables
@STACK   DS    A             address of stack pointer
@LENGTH  DS    A             address of stack length
@COMM    DS    A             address of communication area
         EJECT ,
*-------------------------------------------------------------------*
* Format of parse table:                                            *
*                                                                   *
*        The table address passsed as argument has the following    *
*        header containing pointers, etc.  This table is generated  *
*        by the GENASM program which reads the PAT .TAB file and    *
*        builds the assembler source.  Make sure that if GENASM     *
*        changes that this gets fixed to match it.                  *
*-------------------------------------------------------------------*
         SPACE ,
PATTBL   DSECT ,             PAT/LALR parse table
STARTST  DS    F             start state
CONTCODE DS    F             continue code in SYMLIST
ELSECODE DS    F             else code in SYMLIST
ERRCODE  DS    F             error code in SYMLIST
SCANCODE DS    F             scan code in SYMLIST
VOCSIZE  DS    F             size of vocabulary
MAXTERM  DS    F             highest numbered terminal symbol
MAXSTATE DS    F             number of states
MAXPROD  DS    F             number of productions
ASYMLIST DS    A             address of symlist array
AACTION  DS    A             address of action array
ALHSTOKE DS    A             address of lhstoken array
APOPTOKE DS    A             address of poptoken array
ASEMANTI DS    A             address of semantic array
AKEYTAB  DS    A             address of keytab array
AKEYVAL  DS    A             address of keyval array
ALEX     DS    A             address of lexical routine
ASHIFT   DS    A             address of semantic shift routine
         EJECT ,
*-------------------------------------------------------------------*
* Local variables:                                                  *
*                                                                   *
*        A register save area and local variables are allocated     *
*        from the stack.  R13 is then used as the base for this     *
*        save area so that any routines called by this one see      *
*        the standard OS linkage.                                   *
*-------------------------------------------------------------------*
         SPACE ,
LOCALS   DSECT ,             save area and local variables
         DS    18F           standard OS save area
COMM     DS    A             communications area pointer
APSTACK  DS    A             address of parser stack
MAXSTACK DS    F             max depth of parser stack
FLAG     DS    X             flags
SCAN     EQU   X'80'
PARSE    EQU   X'40'
REDUCE   EQU   X'20'
MATCH    EQU   X'10'
         DS    0D            keep the stack dword aligned
LOCSIZE  EQU   *-LOCALS      length of local variables area
         EJECT ,
*-------------------------------------------------------------------*
* Register definitions:                                             *
*-------------------------------------------------------------------*
         SPACE ,
R0       EQU   0             work
R1       EQU   1             <--+
R2       EQU   2                |
R3       EQU   3                |
R4       EQU   4                | Renamed for use as
R5       EQU   5                | parser variables below
R6       EQU   6                |
R7       EQU   7                |
R8       EQU   8                |
R9       EQU   9             <--+
R10      EQU   10            work
R11      EQU   11            PATTBL dsect base
R12      EQU   12            code base
R13      EQU   13            local variables base
R14      EQU   14            work
R15      EQU   15            work
* alternate register names (parser state variables)
T1       EQU   R1            temporary for array indexing
T2       EQU   R2            "
TOKEN    EQU   R3            current input token
SP       EQU   R4            stack pointer
CURSTATE EQU   R5            current state
TRAN     EQU   R6            transfer
ACT      EQU   R7            action
J        EQU   R8            loop variable
NEXT     EQU   R9            next token
         EJECT ,
*-------------------------------------------------------------------*
*        The main program -                                         *
*              - set up stack, etc. w/MENTRY macro                  *
*-------------------------------------------------------------------*
         SPACE ,
MAILLRP  CSECT ,
LRPARSE  MENTRY STK=@STACK,SLEN=@LENGTH
         USING PARMS,R1      address parameter list
         SRL   R2,2          divide remaining length by 4
         ST    R2,MAXSTACK   this is maximum stack depth
         ST    R15,APSTACK   address of parser stack
         L     R11,@TABLE    address of parse tables
         USING PATTBL,R11    get addressability
         L     R2,@COMM      communications area pointer
         ST    R2,COMM       save here for later use
         DROP  R1            done with parameters
         SPACE ,
*-------------------------------------------------------------------*
*        START -                                                    *
*              - Get first token                                    *
*              - set current state to start state                   *
*              - scan,parse flags set TRUE                          *
*              - match,reduce flags set FALSE                       *
*              - stack pointer to zero                              *
*-------------------------------------------------------------------*
         SR    TRAN,TRAN     start with nice empty values
         SR    ACT,ACT       "
         SR    J,J           "
         SR    NEXT,NEXT     "
         L     R15,ALEX      address of lexical routine
         L     R1,COMM       communication data
         BALR  R14,R15       call lex to get the token
         LTR   R15,R15       did LEX croak?
         BNZ   LEXERR        -> time to die.
         LR    TOKEN,R1      token code returned in R1
         L     CURSTATE,STARTST set start state
         MVI   FLAG,SCAN+PARSE set scan,parse true; match,reduce false
         SR    SP,SP         stack pointer to zero
         SPACE ,
*-------------------------------------------------------------------*
*        PARSELOOP -                                                *
*              - if parse flag is false,  quit                      *
*              - j <- current state                                 *
*              - search for a matching token                        *
*-------------------------------------------------------------------*
PARSELP  EQU   *             <- main loop of parser
         LR    J,CURSTATE    set search variable to current state
         DEBUG 'Top of Parse loop'
         SPACE ,
*-------------------------------------------------------------------*
*        MATCHLOOP -                                                *
*              - search for matching token, etc.                    *
*-------------------------------------------------------------------*
MATCHLP  EQU   *             <- match loop
         NI    FLAG,X'FF'-MATCH set match flag false
         LDAR@ TRAN,SYMLIST,J transition for this state
         DEBUG 'Top of matchlp; after tran=symlist(j)'
         CR    TRAN,TOKEN    matched the token?
         BE    MATCHED       -> you bet.
         C     TRAN,ELSECODE or default marker?
         BE    MATCHED       -> ditto.
         C     TRAN,CONTCODE maybe got a continue code?
         BE    MATCHLP1      -> yes, go get action
         A     J,=F'1'       increment search index
         B     MATCHEND      -> and try again
MATCHLP1 EQU   *             <- get action
         LDAR@ J,ACTION,J    get action
         B     MATCHEND      -> and search from there
         SPACE ,
*-------------------------------------------------------------------*
*        MATCHED -                                                  *
*              - matched a token (or defaulted)                     *
*              - get the action and see if shift or reduce          *
*-------------------------------------------------------------------*
MATCHED  EQU   *             <- matched
         OI    FLAG,MATCH    set match logical variable true
         LDAR@ ACT,ACTION,J  get action
         C     ACT,ERRCODE   is the action 'error'?
         BE    ERROR         -> parse error
         L     R0,SCANCODE   get -scan_code
         LCR   R0,R0         complement it
         CR    ACT,R0        is act <= -scancode?
         BNH   MATCHED2      -> shift
         STAR@ CURSTATE,PSTACK,SP put current state on parser stack
         TM    FLAG,REDUCE   if reduce is false, do user semantics
         BO    NOUSEM        -> don't do user semantic stack stuff
         DEBUG 'calling SHIFT semantic'
         L     R15,ASHIFT    address of shift semantic
         L     R1,COMM       communications area pointer
         LR    R0,SP         pass stack pointer in R0
         BALR  R14,R15       call it
         DEBUG 'return from SHIFT semantic'
NOUSEM   EQU   *             <- skipped user semantic stack
MATCHED2 EQU   *             <- shift or reduce?
         LTR   ACT,ACT       see if action is < 0
         BL    REDUCE1       -> yes; reduce
         LR    CURSTATE,ACT  set new current state
         NI    FLAG,X'FF'-REDUCE set reduce false
         A     SP,=F'1'      bump stack pointer
         C     SP,MAXSTACK   did that overflow the stack?
         BNL   STKOVER       -> to deep for me!
         DEBUG 'Matched2: testing scan for token = lex()'
         TM    FLAG,SCAN     is scan true?
         BO    READLEX       -> get another token
         OI    FLAG,SCAN     set scan true for next time thru
         LR    TOKEN,NEXT    get the lookahead token
         B     MATCHEND      -> and do it again
READLEX  EQU   *             <- read the next token
         L     R15,ALEX      address of lexical routine
         L     R1,COMM       communication area pointer
         BALR  R14,R15       call lex
         LTR   R15,R15       did LEX choke
         BNZ   LEXERR        -> time to die
         LR    TOKEN,R1      lex puts token code into r1
         B     MATCHEND      -> back to the match loop
         SPACE ,
*-------------------------------------------------------------------*
*        REDUCE -                                                   *
*              - pop stack                                          *
*              - call user semantics                                *
*-------------------------------------------------------------------*
REDUCE1  EQU   *             <- reduce
         L     R0,SCANCODE   get scan code
         LCR   R0,R0         -scancode
         CR    ACT,R0        is act > -scancode?
         BH    REDUCE2       -> no scan
         A     ACT,SCANCODE  add scancode to Act
         NI    FLAG,X'FF'-SCAN clear scan logical variable
         S     SP,=F'1'      one extra pop for no scan reductions
         LR    NEXT,TOKEN    set the lookahead token
REDUCE2  EQU   *             <- no a no scan reduction
         LCR   ACT,ACT       set act = -act
         LDAR@ R0,POPTOKEN,ACT number of tokens to pop
         SR    SP,R0         pop the stack
         C     R0,=F'-1'     is this a null rule?
         BNE   NONULL        -> not a null rule reduction
         STAR@ CURSTATE,PSTACK,SP fudge the stack
NONULL   EQU   *             here when not a null reduction
         LDAR@ CURSTATE,PSTACK,SP set new current state
         LDAR@ TOKEN,LHSTOKEN,ACT get lhs of rule
         OI    FLAG,REDUCE   set reduce true
         LDAR@ R15,SEMANTIC,ACT get semantic for this reduction
         LTR   R15,R15       no semantic routine for this reduction?
         BZ    MATCHEND     -> no user semantics
         DEBUG 'Calling user semantic'
         L     R1,COMM       pass ptr to comm area to semantics
         LR    R0,SP         pass stack pointer too.
         BALR  R14,R15       call it
         LTR   R15,R15       check return code of semantic
         BZ    MATCHEND      -> no trouble
         NI    FLAG,X'FF'-PARSE non-zero ret means set parse false
MATCHEND EQU   *             <- end of match loop
         TM    FLAG,MATCH    check match flag
         BNO   MATCHLP       match is false; back to match loop
         TM    FLAG,PARSE    check parse flag
         BO    PARSELP       back to parse loop
         SR    R15,R15       clear return code for normal end.
         SPACE ,
*-------------------------------------------------------------------*
*        ENDPRS -                                                   *
*              - Done parsing                                       *
*-------------------------------------------------------------------*
ENDPRS   EQU   *             <- end of parse loop
         MRET  ,             return via MENTRY macro
         SPACE ,
*-------------------------------------------------------------------*
*        ERROR -                                                    *
*              - parse error                                        *
*              - dump parse stack?                                  *
*-------------------------------------------------------------------*
         SPACE ,
ERROR    EQU   *             <- parse error
         DEBUG 'Syntax error.'
         LA    R15,20        set error code
         B     ENDPRS        and return
         SPACE ,
LEXERR   EQU   *             <- error from LEX
         DEBUG 'Lexical scanner error.'
         B     ENDPRS        and return
         SPACE ,
STKOVER  EQU   *             <- stack overflow
         DEBUG 'Parser stack overflow!'
         LA    R15,16        error code
         B     ENDPRS        -> return
         LTORG ,
         AIF   (NOT &DODEBUG).NODB
         MNOTE *,'Debugging produces non-reentrant code'
         EJECT ,
*-------------------------------------------------------------------*
* Debugger:                                                         *
*                                                                   *
*        Prints a variable message and parser variables.            *
*-------------------------------------------------------------------*
         SPACE ,
DBGPRT   DS    0H
         STM   R14,R12,12(R13)         save caller's registers
         SR    R14,R14       clear r14
         IC    R14,0(R1)     get length of string
         LA    R10,1(R1)     get address of string
         WRTERM '------------------------'
         WRTERM (R10),(R14)  write debugger statement
         LINEDIT TEXT='Token: ........ SP: ........ Curstate: ........ *
               Tran: ........ act: ........ j: ........ Next: ........'*
               ,SUB=(DEC,(TOKEN),DEC,(SP),DEC,(CURSTATE),              *
               DEC,(TRAN),DEC,(ACT),DEC,(J),DEC,(NEXT)),RENT=NO
         TM    FLAG,SCAN     true?
         BO    DBG1          yup
         WRTERM 'Scan = False, ',EDIT=LONG
         B     DBG2
DBG1     EQU   *
         WRTERM 'Scan = True, ',EDIT=LONG
DBG2     EQU   *
         TM    FLAG,PARSE    true?
         BO    DBG3          yup
         WRTERM 'Parse = False ,',EDIT=LONG
         B     DBG4
DBG3     EQU   *
         WRTERM 'Parse = True ,',EDIT=LONG
DBG4     EQU   *
         TM    FLAG,MATCH    true?
         BO    DBG5          yup
         WRTERM 'Match = False, ',EDIT=LONG
         B     DBG6
DBG5     EQU   *
         WRTERM 'Match = True, ',EDIT=LONG
DBG6     EQU   *
         TM    FLAG,REDUCE   true?
         BO    DBG7          yup
         WRTERM 'Reduce = False'
         B     DBG8
DBG7     EQU   *
         WRTERM 'Reduce = True'
DBG8     EQU   *
         WRTERM '-----------------------'
         WAITT ,
         LM    R14,R12,12(R13)
         BR    R14
         LTORG ,
.NODB    ANOP
         MPEND ,             end of procedure
         END   ,
